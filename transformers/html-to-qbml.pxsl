<<<?xml version="1.0" encoding="UTF-8" ?>>>

# The expected format of the HTML document is basically this, where every line is contained in a <p>,
# and empty lines are just <p><br /></p>.
#
#   Tournament name and year: Subtitle (TODO)
#   Packet by <Packet name>
#   Questions/Edited by <Authors>
#
#   Tossups
#
#   1. Blah blah.
#   ANSWER: Blah blah.
#
#   Bonuses
#
#   1. Blah blah.
#   [10] Blah blah.
#   ANSWER: Blah blah.
#   [10] Blah blah.
#   ANSWER: Blah blah.
#   [10] Blah blah.
#   ANSWER: Blah blah.
#
# Notice that the components of tossups and bonuses are determined by their position relative to the
# preceding <p><br /></p>.
#
# TODO: Wrap all substring-after() with if starts-with() 

,strip el =
  call-template strip
    with-param p <(,el)>
    with-param s
      ,BODY

,tag source result =
  template <(,source)>
    element <(,result)>
      apply-templates

stylesheet -version=1.0 -xmlns:xsl=http://www.w3.org/1999/XSL/Transform
  output -method=xml -indent=no -encoding=UTF-8
  preserve-space *

  include ../tournaments/metadata.xsl

  template html
    param packet <<Packet >>
    param by <<by >>
    qpdb -version=0.2
      tournaments
        # TODO: Take this hardcoding out of the stylesheet; also UTF-8 does not work
        tournament
          call-template metadata
          packets
            variable packet-name
              choose
                when contains(p[2],'Editors')
                  text <<Editors >>
                  value-of substring-after(p[2],$packet)
                otherwise
                  value-of substring-after(p[2],$by)
            packet -name={$packet-name} -authors={substring-after(p[3],$by)}
              tossups
                apply-templates p[text()='Tossups']
              boni
                apply-templates p[text()='Bonuses']

  template p[text()='Tossups']
    for-each -select=<<following-sibling::p[(preceding-sibling::p[1])[br] and following-sibling::p[text()='Bonuses']]>>
      tossup -id={substring-before(text(),'.')}
        question
          ,strip . <<. >>
        answer
          call-template strip-answer
            with-param p following-sibling::p[1]

  template p[text()='Bonuses']
    for-each -select=<<following-sibling::p[(preceding-sibling::p[1])[br and not(text())]]>>
      bonus -id={substring-before(text(),'.')}
        variable cur generate-id(preceding::br[ancestor::p[1][not(text())]][1])
        stem
          ,strip . <<. >>
        for-each -select=<<following-sibling::p[generate-id(preceding::br[ancestor::p[1][not(text())]][1]) = $cur and starts-with(text(), '[10]')]>>
          part -value=10
            question
              ,strip . <<[10] >>
            answer
              call-template strip-answer
                with-param p following-sibling::p[1]

  template -name=strip
    param p
    param s
    variable temp
      apply-templates $p/text()[1]
    value-of substring-after($temp,$s)
    apply-templates $p/*|$p/text()[not(position()=1)]

  template -name=strip-answer
    # Sometimes a typo like "ANWER: " or "ANSWER " will cause substring-after to fail, but you may be lucky enough
    # that the actual answer starts with a tag (instead of more text) that it cancels out.
    param p
    ,strip $p <<ANSWER: >>

  template p
    apply-templates

  ,tag strong req
  ,tag em title
  ,tag sup sup
  ,tag sub sub
  ,tag br br
